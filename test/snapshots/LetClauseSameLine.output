module LetClauseSameLine where

-- Simple let expression with single binding
simple =
  let
    x = 42
  in
    x + 1

-- Multiple bindings in let (should still break)
multiple =
  let
    a = 1
    b = 2
    c = a + b
  in
    c * 2

-- Let with type signatures (should still break)
withTypes =
  let
    helper :: Int -> Int
    helper x = x + 1

    value :: Int
    value = 42
  in
    helper value

-- Nested let expressions
nested =
  let
    outer = 10
  in
    let
      inner = 20
    in
      outer + inner

-- Let in case branch (single binding)
caseLetSingle = case x of
  Just a ->
    let
      helper = a + 1
    in
      helper * 2
  Nothing -> 0

-- Let in case branch (multiple bindings)
caseLetMultiple = case x of
  Just a ->
    let
      helper = a + 1
      other = a * 2
    in
      helper + other
  Nothing -> 0

-- Let in if-then-else
ifLetSingle =
  if condition then
    let
      helper = 42
    in
      helper * 2
  else 0

-- Let in guarded expression
guardLetSingle x
  | x > 0 =
      let
        positive = x * 2
      in
        positive + 1
  | otherwise =
      let
        negative = x * (-1)
      in
        negative - 1

-- Let in do notation (single binding)
doLetSingle = do
  result <- getSomething
  let helper = result + 1
  pure helper

-- Let in do notation (multiple bindings)
doLetMultiple = do
  result <- getSomething
  let
    helper = result + 1
    other = result * 2
  pure (helper + other)

-- Let in ado notation (single binding)
adoLetSingle = ado
  result <- getSomething
  let helper = result + 1
  in helper * 2

-- Let in ado notation (multiple bindings)
adoLetMultiple = ado
  result <- getSomething
  let
    helper = result + 1
    other = result * 2
  in helper + other

-- Let with complex expression body
complexBody =
  let
    x = 1
  in
    case x of
      1 -> "one"
      _ -> "other"

-- Let with where clause
letWithWhere =
  let
    x = helper
  in
    x + 1
  where
  helper = 42

-- Deeply nested lets
deeplyNested =
  let
    a = 1
  in
    let
      b = 2
    in
      let
        c = 3
      in
        a + b + c

-- Let with lambda
letWithLambda =
  let
    f = \x -> x + 1
  in
    f 42

-- Let with record
letWithRecord =
  let
    rec = { x: 1, y: 2 }
  in
    rec.x + rec.y

-- Let with array
letWithArray =
  let
    arr = [ 1, 2, 3 ]
  in
    length arr

-- Let with multiline single binding that breaks
letWithLongBinding =
  let
    veryLongVariableName = veryLongFunctionName arg1 arg2 arg3 arg4 arg5
  in
    veryLongVariableName + 1

-- Let in pattern binding
patternLet =
  let
    Tuple a b = tuple
  in
    a + b

-- Multiple sequential lets
sequentialLets =
  let
    x = 1
  in
    let
      y = 2
    in
      let
        z = 3
      in
        x + y + z

-- Let with operator application
letWithOps =
  let
    result = x <> y <> z
  in
    result <> "!"

-- Let in lambda body
lambdaLet = \x ->
  let
    y = x * 2
  in
    y + 1

-- Let with do block in binding
letWithDo =
  let
    action = do
      x <- getSomething
      y <- getSomethingElse
      pure (x + y)
  in
    runAction action

-- @format --let-clause-same-line
module LetClauseSameLine where

-- Simple let expression with single binding
simple =
  let x = 42
  in  x + 1

-- Multiple bindings in let (should still break)
multiple =
  let a = 1
  b = 2
  c = a + b
  in  c * 2

-- Let with type signatures (should still break)
withTypes =
  let helper :: Int -> Int
  helper x = x + 1

  value :: Int
  value = 42
  in  helper value

-- Nested let expressions
nested =
  let outer = 10
  in  let inner = 20
  in  outer + inner

-- Let in case branch (single binding)
caseLetSingle = case x of
  Just a ->
    let helper = a + 1
    in  helper * 2
  Nothing -> 0

-- Let in case branch (multiple bindings)
caseLetMultiple = case x of
  Just a ->
    let helper = a + 1
    other = a * 2
    in  helper + other
  Nothing -> 0

-- Let in if-then-else
ifLetSingle =
  if condition then
    let helper = 42
    in  helper * 2
  else 0

-- Let in guarded expression
guardLetSingle x
  | x > 0 =
      let positive = x * 2
      in  positive + 1
  | otherwise =
      let negative = x * (-1)
      in  negative - 1

-- Let in do notation (single binding)
doLetSingle = do
  result <- getSomething
  let helper = result + 1
  pure helper

-- Let in do notation (multiple bindings)
doLetMultiple = do
  result <- getSomething
  let
    helper = result + 1
    other = result * 2
  pure (helper + other)

-- Let in ado notation (single binding)
adoLetSingle = ado
  result <- getSomething
  let helper = result + 1
  in helper * 2

-- Let in ado notation (multiple bindings)
adoLetMultiple = ado
  result <- getSomething
  let
    helper = result + 1
    other = result * 2
  in helper + other

-- Let with complex expression body
complexBody =
  let x = 1
  in  case x of
    1 -> "one"
    _ -> "other"

-- Let with where clause
letWithWhere =
  let x = helper
  in  x + 1
  where
  helper = 42

-- Deeply nested lets
deeplyNested =
  let a = 1
  in  let b = 2
  in  let c = 3
  in  a + b + c

-- Let with lambda
letWithLambda =
  let f = \x -> x + 1
  in  f 42

-- Let with record
letWithRecord =
  let rec = { x: 1, y: 2 }
  in  rec.x + rec.y

-- Let with array
letWithArray =
  let arr = [ 1, 2, 3 ]
  in  length arr

-- Let with multiline single binding that breaks
letWithLongBinding =
  let veryLongVariableName = veryLongFunctionName arg1 arg2 arg3 arg4 arg5
  in  veryLongVariableName + 1

-- Let in pattern binding
patternLet =
  let Tuple a b = tuple
  in  a + b

-- Multiple sequential lets
sequentialLets =
  let x = 1
  in  let y = 2
  in  let z = 3
  in  x + y + z

-- Let with operator application
letWithOps =
  let result = x <> y <> z
  in  result <> "!"

-- Let in lambda body
lambdaLet = \x ->
  let y = x * 2
  in  y + 1

-- Let with do block in binding
letWithDo =
  let action = do
    x <- getSomething
    y <- getSomethingElse
    pure (x + y)
  in  runAction action
