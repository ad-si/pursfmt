module Bin.FormatOptions where

import Prelude

import ArgParse.Basic (ArgParser)
import ArgParse.Basic as Arg
import Control.Alt ((<|>))
import Control.Monad.Error.Class (throwError)
import Data.Argonaut.Core (Json, jsonEmptyObject, jsonNull)
import Data.Argonaut.Core as Json
import Data.Argonaut.Decode (JsonDecodeError(..), decodeJson, (.:?))
import Data.Argonaut.Encode (assoc, encodeJson, extend)
import Data.Either (Either)
import Data.Maybe (Maybe(..), fromMaybe, maybe)
import Data.Newtype (class Newtype)
import Data.Traversable (traverse)
import Data.YAML.Foreign.Encode (class ToYAML, entry, object)
import Pursfmt (ImportSortOption(..), ImportWrapOption(..), ThenPlacementOption(..), TypeArrowOption(..), UnicodeOption(..))

type FormatOptions =
  { importSort :: ImportSortOption
  , importWrap :: ImportWrapOption
  , indent :: Int
  , operatorsFile :: Maybe String
  , ribbon :: Number
  , thenPlacement :: ThenPlacementOption
  , typeArrowPlacement :: TypeArrowOption
  , unicode :: UnicodeOption
  , width :: Maybe Int
  , whereClauseSameLine :: Boolean
  , compactRecords :: Boolean
  , letClauseSameLine :: Boolean
  }

-- Newtype wrapper for ToYAML instance
newtype FormatOptionsYAML = FormatOptionsYAML FormatOptions

derive instance Newtype FormatOptionsYAML _

defaults :: FormatOptions
defaults =
  { importSort: ImportSortSource
  , importWrap: ImportWrapSource
  , indent: 2
  , operatorsFile: Nothing
  , ribbon: 1.0
  , thenPlacement: ThenSameLine
  , typeArrowPlacement: TypeArrowFirst
  , unicode: UnicodeSource
  , width: Nothing
  , whereClauseSameLine: false
  , compactRecords: false
  , letClauseSameLine: false
  }

formatOptions :: ArgParser FormatOptions
formatOptions =
  Arg.fromRecord
    { importSort:
        Arg.choose "import sort"
          [ Arg.flag [ "--import-sort-source", "-iss" ]
              "Imports are not automatically sorted and keep the same order as in the source.\nDefault."
              $> ImportSortSource
          , Arg.flag [ "--import-sort-ide", "-isi" ]
              "Imports are automatically sorted like purs-ide."
              $> ImportSortIde
          ]
          # Arg.default defaults.importSort
    , importWrap:
        Arg.choose "import wrap"
          [ Arg.flag [ "--import-wrap-source", "-iws" ]
              "Imports are wrapped only when breaks are in the source.\nDefault. Works well with IDE imports."
              $> ImportWrapSource
          , Arg.flag [ "--import-wrap-auto", "-iwa" ]
              "Imports are wrapped based on the `--width` option."
              $> ImportWrapAuto
          ]
          # Arg.default defaults.importWrap
    , indent:
        Arg.argument [ "--indent", "-i" ]
          "Number of spaces to use as indentation.\nDefaults to 2."
          # Arg.int
          # Arg.default defaults.indent
    , operatorsFile:
        Arg.argument [ "--operators", "-o" ]
          "Path to an operator table generated by `generate-operators`.\nDefault is to use a pre-generated table of core and contrib."
          # Arg.unformat "FILE_PATH" pure
          # Arg.optional
    , ribbon:
        Arg.argument [ "--ribbon", "-r" ]
          "The ratio of printable width to maximum width.\nFrom 0 to 1. Defaults to 1."
          # Arg.number
          # Arg.default defaults.ribbon
    , thenPlacement:
        Arg.choose "then placement"
          [ Arg.flag [ "--then-same-line", "-tsl" ]
              "Then keyword is placed on the same line as the if condition.\nDefault."
              $> ThenSameLine
          , Arg.flag [ "--then-new-line-always", "-tnl" ]
              "Then keyword is placed on a new line, regardless of width."
              $> ThenNewLineAlways
          , Arg.flag [ "--then-new-line-for-long-line", "-tnlfl" ]
              "Then keyword is placed on a new line only when the line would exceed the available width."
              $> ThenNewLineForLongLine
          ]
          # Arg.default defaults.thenPlacement
    , typeArrowPlacement:
        Arg.choose "type arrow placement"
          [ Arg.flag [ "--arrow-first", "-af" ]
              "Type signatures put arrows first on the line.\nDefault."
              $> TypeArrowFirst
          , Arg.flag [ "--arrow-last", "-al" ]
              "Type signatures put arrows last on the line."
              $> TypeArrowLast
          ]
          # Arg.default defaults.typeArrowPlacement
    , unicode: unicodeOption
    , width:
        Arg.argument [ "--width", "-w" ]
          "The maximum width of the document in columns.\nDefaults to no maximum."
          # Arg.int
          # Arg.optional
    , whereClauseSameLine:
        Arg.flag [ "--where-clause-same-line", "-wcsl" ]
          "Put source code directly after \"where\" instead of the next line."
          # Arg.boolean
    , compactRecords:
        Arg.flag [ "--compact-records", "-cr" ]
          "Format records without additional space at the start and end of the curly brackets."
          # Arg.boolean
    , letClauseSameLine:
        Arg.flag [ "--let-clause-same-line", "-lcsl" ]
          "Put source code directly after \"let\" and \"in\" instead of the next line."
          # Arg.boolean
    }

unicodeOption :: ArgParser UnicodeOption
unicodeOption =
  Arg.choose "unicode argument"
    [ Arg.flag [ "--unicode-source", "-us" ]
        "Unicode punctuation is rendered as it appears in the source input.\nDefault."
        $> UnicodeSource
    , Arg.flag [ "--unicode-always", "-ua" ]
        "Unicode punctuation is always preferred."
        $> UnicodeAlways
    , Arg.flag [ "--unicode-never", "-un" ]
        "Unicode punctuation is never preferred."
        $> UnicodeNever
    ]
    # Arg.default defaults.unicode

fromJson :: Json -> Either JsonDecodeError FormatOptions
fromJson json = do
  obj <- decodeJson json
  importSort <- traverse importSortFromString =<< obj .:? "importSort"
  importWrap <- traverse importWrapFromString =<< obj .:? "importWrap"
  indent <- obj .:? "indent"
  operatorsFile <- obj .:? "operatorsFile"
  ribbon <- obj .:? "ribbon"
  thenPlacement <- traverse thenPlacementFromString =<< obj .:? "thenPlacement"
  typeArrowPlacement <- traverse typeArrowPlacementFromString =<< obj .:? "typeArrowPlacement"
  unicode <- traverse unicodeFromString =<< obj .:? "unicode"
  width <- obj .:? "width"
  whereClauseSameLine <- obj .:? "whereClauseSameLine"
  compactRecords <- obj .:? "compactRecords"
  letClauseSameLine <- obj .:? "letClauseSameLine"
  pure
    { importSort: fromMaybe defaults.importSort importSort
    , importWrap: fromMaybe defaults.importWrap importWrap
    , indent: fromMaybe defaults.indent indent
    , operatorsFile: operatorsFile <|> defaults.operatorsFile
    , ribbon: fromMaybe defaults.ribbon ribbon
    , thenPlacement: fromMaybe defaults.thenPlacement thenPlacement
    , typeArrowPlacement: fromMaybe defaults.typeArrowPlacement typeArrowPlacement
    , unicode: fromMaybe defaults.unicode unicode
    , width: width <|> defaults.width
    , whereClauseSameLine: fromMaybe defaults.whereClauseSameLine whereClauseSameLine
    , compactRecords: fromMaybe defaults.compactRecords compactRecords
    , letClauseSameLine: fromMaybe defaults.letClauseSameLine letClauseSameLine
    }

toJson :: FormatOptions -> Json
toJson options =
  jsonEmptyObject
    # extend (assoc "importSort" (importSortToString options.importSort))
    # extend (assoc "importWrap" (importWrapToString options.importWrap))
    # extend (assoc "indent" options.indent)
    # extend (assoc "operatorsFile" (maybe jsonNull encodeJson options.operatorsFile))
    # extend (assoc "ribbon" options.ribbon)
    # extend (assoc "thenPlacement" (thenPlacementToString options.thenPlacement))
    # extend (assoc "typeArrowPlacement" (typeArrowPlacementToString options.typeArrowPlacement))
    # extend (assoc "unicode" (unicodeToString options.unicode))
    # extend (assoc "width" (maybe jsonNull encodeJson options.width))
    # extend (assoc "whereClauseSameLine" (encodeJson options.whereClauseSameLine))
    # extend (assoc "compactRecords" options.compactRecords)
    # extend (assoc "letClauseSameLine" options.letClauseSameLine)

thenPlacementFromString :: String -> Either JsonDecodeError ThenPlacementOption
thenPlacementFromString = case _ of
  "same-line" -> pure ThenSameLine
  "new-line" -> pure ThenNewLineAlways
  "new-line-always" -> pure ThenNewLineAlways
  "new-line-for-long-line" -> pure ThenNewLineForLongLine
  other -> throwError $ UnexpectedValue (Json.fromString other)

thenPlacementToString :: ThenPlacementOption -> String
thenPlacementToString = case _ of
  ThenSameLine -> "same-line"
  ThenNewLineAlways -> "new-line-always"
  ThenNewLineForLongLine -> "new-line-for-long-line"

typeArrowPlacementFromString :: String -> Either JsonDecodeError TypeArrowOption
typeArrowPlacementFromString = case _ of
  "first" -> pure TypeArrowFirst
  "last" -> pure TypeArrowLast
  other -> throwError $ UnexpectedValue (Json.fromString other)

typeArrowPlacementToString :: TypeArrowOption -> String
typeArrowPlacementToString = case _ of
  TypeArrowFirst -> "first"
  TypeArrowLast -> "last"

unicodeFromString :: String -> Either JsonDecodeError UnicodeOption
unicodeFromString = case _ of
  "source" -> pure UnicodeSource
  "always" -> pure UnicodeAlways
  "never" -> pure UnicodeNever
  other -> throwError $ UnexpectedValue (Json.fromString other)

unicodeToString :: UnicodeOption -> String
unicodeToString = case _ of
  UnicodeSource -> "source"
  UnicodeAlways -> "always"
  UnicodeNever -> "never"

importWrapFromString :: String -> Either JsonDecodeError ImportWrapOption
importWrapFromString = case _ of
  "source" -> pure ImportWrapSource
  "auto" -> pure ImportWrapAuto
  other -> throwError $ UnexpectedValue (Json.fromString other)

importWrapToString :: ImportWrapOption -> String
importWrapToString = case _ of
  ImportWrapSource -> "source"
  ImportWrapAuto -> "auto"

importSortFromString :: String -> Either JsonDecodeError ImportSortOption
importSortFromString = case _ of
  "source" -> pure ImportSortSource
  "ide" -> pure ImportSortIde
  other -> throwError $ UnexpectedValue (Json.fromString other)

importSortToString :: ImportSortOption -> String
importSortToString = case _ of
  ImportSortSource -> "source"
  ImportSortIde -> "ide"

instance toYAMLFormatOptions :: ToYAML FormatOptionsYAML where
  toYAML (FormatOptionsYAML options) =
    object
      [ "importSort" `entry` importSortToString options.importSort
      , "importWrap" `entry` importWrapToString options.importWrap
      , "indent" `entry` options.indent
      , "operatorsFile" `entry` options.operatorsFile
      , "ribbon" `entry` options.ribbon
      , "thenPlacement" `entry` thenPlacementToString options.thenPlacement
      , "typeArrowPlacement" `entry` typeArrowPlacementToString options.typeArrowPlacement
      , "unicode" `entry` unicodeToString options.unicode
      , "width" `entry` options.width
      ]
